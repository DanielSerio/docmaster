# Archive Summary 1

## Server-Side Services Implementation

Established the complete server-side API and service layer infrastructure for DocMaster, implementing a robust three-tier architecture with tRPC routers, business logic services, and comprehensive Zod validation. The implementation covers eight core entity types: rule categories, rules, text blocks, documents, document-rule junctions, document-text block junctions, collections, and collection-document associations.

The service layer implements sophisticated business logic including automatic junction table population when creating documents or content, cascade timestamp updates when modifying junction records, and transaction-based operations to ensure data consistency. When creating a rule document, the system automatically generates junction records for all existing rules with appropriate default priorities and enabled states. Similarly, creating general documents auto-populates junctions for all text blocks, and creating new content automatically associates it with existing documents of the appropriate type.

All tRPC endpoints enforce strict input and output validation using Zod schemas defined in a centralized schema directory. Input validation ensures data integrity before reaching the service layer, while output validation guarantees that responses always match documented contracts, providing end-to-end type safety from database to client. The schema architecture uses composable patterns, with base schemas extended for nested relations and reused across input/output definitions.

Error handling covers common database constraints including uniqueness violations for duplicate names and foreign key violations for invalid references. The system properly manages timestamps using Prisma's automatic updatedAt behavior, with manual cascade updates when junction changes affect parent documents. All multi-step operations use Prisma transactions to maintain atomicity, particularly for document and content creation with junction population.

The implementation provides complete CRUD operations for all entities, specialized junction management endpoints for updating priorities and toggling enabled states, and proper cascade delete behavior to maintain referential integrity. All routers are integrated into a unified AppRouter exported for client-side type safety via tRPC's type inference capabilities.

## DataTable Server-Side Filtering System

Implemented a comprehensive server-side filtering system for DataTable components that supports dynamic filter UI generation based on column metadata configurations. The system integrates TanStack Table's column filtering API with tRPC for type-safe communication between client and server, enabling efficient filtering of large datasets at the database level.

The architecture introduces a custom useDataTableFiltering hook that manages filter state using TanStack Table's ColumnFiltersState, providing methods for setting, clearing, and retrieving individual filters as well as bulk operations. Filter configurations are defined in column metadata using a discriminated union type system that ensures type-safe filter definitions with five supported filter types: search (text substring matching), select (single option dropdown), multi-select (multiple option checkboxes), date-range (calendar-based date selection), and number-range (min/max numeric inputs).

Five specialized filter UI components were created in the data-table filters directory, each implementing a consistent DTFilterProps interface and leveraging Shadcn UI components for unified styling. The DTFilter orchestrator component dynamically renders appropriate filter controls based on column metadata, displays column labels, and provides a "Clear All" button when filters are active. These components are exported as compound components on the DataTable for use in the Filters slot.

Server-side integration uses tRPC to receive the ColumnFiltersState array directly without serialization, with Zod validation ensuring type safety. The server implementation dynamically builds Prisma where clauses by iterating through the filters array and applying appropriate operators based on value types: contains for text search with case-insensitive matching, exact match for select filters, in operator for multi-select arrays, and gte/lte for date and number ranges with support for partial ranges. The same where clause applies to both data and count queries to ensure accurate pagination totals.

The system enables automatic query refetching when filter state changes through TanStack Query's dependency tracking, maintains filter state across pagination operations, and provides proper loading and empty states. Filter state is persisted in React state but not synchronized to URL query parameters, though this remains a viable future enhancement for shareable filtered views.

## DataTable Server-Side Sorting System

Implemented a comprehensive server-side sorting system for DataTable components that enables users to sort table data by clicking column headers, supporting both single-column and multi-column sorting with visual priority indicators. The system integrates TanStack Table's sorting API with tRPC for type-safe communication, performing all sorting operations at the database level for optimal performance with large datasets.

The architecture introduces a custom useDataTableSorting hook that manages sort state using TanStack Table's SortingState, providing methods for toggling sorts with a three-state cycle (none → ascending → descending → none), clearing individual sorts, and resetting all sorting. The hook supports multi-column sorting through Shift+click detection, maintaining sort priority based on the order columns were clicked. Column metadata is extended with a sortable property that accepts either a boolean flag for simple sorting or a configuration object for advanced options like default sort direction and custom field name mapping.

Visual feedback is provided through a DTSortIndicator component that displays directional arrows for sort state: up arrow for ascending, down arrow for descending, and a subtle up/down icon on hover for sortable but unsorted columns. When multiple columns are sorted, priority badges display numbered indicators showing the sort order, making it clear which sorts take precedence. The column headers themselves become interactive with click handlers integrated directly into DTTableHeader, applying hover states and cursor changes to communicate sortability.

Server-side implementation was refactored for maintainability by extracting sorting logic into a dedicated utility module at server/src/utils/sorting.ts. The buildDocumentSortingOrderBy function validates client-provided column IDs against an allowlist of valid database fields, preventing potential crashes from malicious or malformed requests. The utility maps column IDs to database field names, generates appropriate Prisma orderBy clauses for both single and multi-column sorts, and gracefully handles invalid inputs by filtering them out and falling back to default sorting when no valid sorts remain.

The sorting system integrates seamlessly with existing pagination and filtering, with all three state dimensions (paging, filtering, sorting) passed independently to tRPC queries. TanStack Query's automatic dependency tracking ensures queries refetch when sort state changes, maintaining consistency between UI state and displayed data. Sort state persists across pagination navigation, allowing users to browse sorted results across multiple pages without losing their sort configuration.

## Collection List DataTable Implementation

Implemented the Collection list page using the standardized four-step DataTable pattern, mirroring the Document list implementation with entity-specific adaptations. The feature provides a fully functional collection browsing interface with server-side pagination, filtering by name and creation date, and multi-column sorting capabilities.

The server-side implementation added filtering and sorting support to the existing collection.getAll tRPC endpoint. A buildCollectionFiltersWhere utility was created in the filters module to handle name search with case-insensitive substring matching and date range filtering on the createdAt field with support for partial ranges. The buildCollectionSortingOrderBy utility in the sorting module enables sorting by name, createdAt, and updatedAt fields with proper validation against an allowlist of valid database fields. The collection service was updated to apply these utilities, generating appropriate Prisma where clauses and orderBy configurations while maintaining consistency between data queries and count queries for accurate pagination totals.

The client-side implementation follows the established DataTable pattern with a custom useCollectionListQuery hook managing query state, error handling, and pagination metadata updates. The useCollectionTableColumns hook defines four columns: line numbers for row identification, a name column with links to collection detail pages plus search filter and sort capabilities, a createdAt column with date range filter and sorting, and an updatedAt column with sorting only. The CollectionListPage component orchestrates the three controller hooks for pagination, filtering, and sorting, passing all state to the query hook and rendering the DataTable with appropriate slots for the title bar containing a "Create Collection" button and the filters UI.

The implementation demonstrates the reusability of the DataTable architecture, with the only differences from the Document list being entity-specific names, schema fields, routes, and display text. All filtering, sorting, and pagination logic remains consistent across entity types, validating the frontend architecture's design for handling different data models through the same standardized pattern. Filter and sort state persists correctly across pagination, loading states display skeleton placeholders, empty states provide helpful messaging, and error handling integrates with the global error context.

## Collection Creation Form Implementation

Implemented a streamlined collection creation form following the established form pattern from document creation, featuring a single-field interface for creating new document collections. The feature provides a minimal yet complete user experience for collection creation with comprehensive validation, error handling, and navigation flow.

The server-side implementation leveraged the existing tRPC documentCollection.create endpoint which accepts a CreateDocumentCollectionInput containing only a name field. The endpoint validates the input against the schema requiring a string between 1 and 255 characters, creates the collection record in the database via Prisma, and returns the created collection with auto-generated id and timestamps. The service layer uses the standard withErrorHandling wrapper to manage database constraint violations including duplicate name errors from the unique constraint on the name field.

The client-side implementation follows the four-component form architecture pattern with a useCollectionForm hook managing form state through React Hook Form and Zod validation, a useCreateCollectionMutation hook wrapping the tRPC mutation with success and error callbacks, a CollectionForm component rendering the single name input field with FieldSet styling and AsyncButton submission control, and a CollectionCreatePage wrapper component that includes breadcrumb navigation linking back to the collections list. The form validates name input in real-time with the submit button disabled until a valid name is entered, displays loading state during submission via the AsyncButton's isBusy prop, navigates to the collections list on success, and integrates with the global error context to display server errors including duplicate name violations.

An initial implementation issue where the mutation hook incorrectly called trpc.collection.create instead of trpc.documentCollection.create to match the server router configuration was identified and resolved. The page component was also enhanced to include breadcrumb navigation matching the document creation pattern, displaying "Collections → New Collection" with the collections link clickable for easy navigation back to the list. The implementation validates the form architecture's reusability across different entity types while demonstrating how simpler forms with fewer fields follow the same structural patterns as more complex multi-field forms.

## EditSheet Component for Inline Table Editing

Implemented the EditSheet component as a compound component that provides inline table editing capabilities with batch save operations, designed specifically for managing child entities without page navigation. Unlike DataTable which provides view-only tables with navigation to separate CRUD pages, EditSheet enables users to add, edit, and delete multiple records directly within the table interface, with all changes batched and submitted atomically in a single transaction.

The architecture uses a view/edit mode toggle pattern where view mode provides read-only display matching DataTable's appearance, while edit mode transforms all cells into editable inputs with an additional actions column containing delete buttons. State management tracks three categories of changes: new rows to create, updated rows to modify, and deleted row IDs to remove. Changes are accumulated locally without server communication until the user clicks Save, at which point all changes are submitted in a single batch API call. The cancel operation with confirmation dialog allows users to discard all uncommitted changes and reset to the original server state.

The server-side implementation introduces a batch update endpoint pattern accepting three arrays in a single transaction: newItems for records to create, updatedItems with IDs for records to modify, and deletedIds for records to remove. Prisma transactions ensure atomicity with operations ordered as delete, update, then create to avoid constraint violations. The endpoint returns the complete updated list of records after all operations complete, enabling the client to refresh the table with accurate server state. For the rules implementation specifically, the batch endpoint handles rule creation with category upsert logic, update operations for rule content and priority, and deletion with proper cascade handling.

The client-side architecture follows a compound component pattern with subcomponents exported as properties on the main EditSheet component. The root EditSheet component manages mode state, change tracking via Maps and Sets for efficient updates and lookups, validation state across all rows, and batch save coordination with loading states. The EditSheetNavigator wrapper provides keyboard navigation with arrow keys supporting up/down movement between rows, left/right movement between columns, and intelligent wrapping from last column to first column of next row. The EditSheetTable, ESTableHeader, and ESTableBody components render the table structure with conditional view/edit cell rendering based on mode, while ESActions provides delete buttons with visual feedback for deleted rows.

Auto-add row functionality triggers when the user focuses any field in the bottom empty row, automatically adding a new blank row below while preserving focus in the current field to avoid interrupting typing. This creates a spreadsheet-like experience where users can continuously add rows by tabbing or navigating down through the table. The implementation uses onFocus handlers rather than onChange to prevent premature additions during typing, with debounce logic to prevent double-adds from rapid focus events.

Column definitions follow an EditSheetColumnDef interface requiring both viewCell and editCell render functions, enabling complete control over how each column displays in both modes. The viewCell receives the row and value, rendering static content like formatted text or icons. The editCell receives row, value, onChange callback, onFocus handler for navigation integration, and disabled flag for deleted rows, rendering appropriate input controls like text inputs, number inputs, checkboxes, or custom components. Column definitions also support optional validation functions that receive the current value and full row object, returning error messages for invalid states.

Validation runs real-time as users edit, tracking errors in a nested Map structure keyed by row index and field ID. Inline error messages display below invalid inputs with red text, and the Save button remains disabled whenever any validation errors exist. The validation system integrates with the change tracking to ensure new and modified rows all pass validation before submission. Common validation rules include required field checks, numeric range validation, and custom business logic validations based on row state.

Keyboard shortcuts enhance the editing experience with Escape key triggering cancel with confirmation, Ctrl+S or Cmd+S triggering save when validation passes, and arrow keys providing Excel-like navigation between cells. The navigator wrapper attaches data-row and data-col attributes to all editable cells, enabling precise focus management through querySelector lookups. Focus transitions include automatic text selection in inputs to facilitate quick overwriting of existing values, matching spreadsheet application behavior.

Delete functionality marks rows with a __deleted flag rather than removing them from the UI immediately, applying visual styling with opacity reduction and strikethrough text to indicate deletion intent. Deleted rows remain visible but with all inputs disabled, and the delete button itself becomes disabled to prevent duplicate deletion attempts. On save, the row IDs are included in the deletedIds array for server-side deletion. The last row delete button is specifically disabled to prevent users from removing the bottom empty row used for adding new entries.

Error handling maintains edit mode when save operations fail, preserving all user changes to allow retry without data loss. Server errors display through the global error context, showing constraint violation messages for issues like duplicate names or foreign key violations. The mutation hook's onError callback prevents mode exit and maintains the local change state, while onSuccess triggers mode exit, change state reset, and query invalidation to refresh the table with server data.

The Rules list page serves as the reference implementation, located at /rules for managing master rules. The page integrates three hooks: useRulesQuery for data fetching, useRulesEditSheetColumns for column definitions with Input for rule content, CategoryTypeAhead for category selection, and Input for priority, and useBatchUpdateRulesMutation for the batch save operation. The batch mutation hook wraps the tRPC rule.batchUpdate endpoint, transforming the EditSheet's BatchChanges payload into the server's expected format with category name extraction from the category object.

The implementation establishes a reusable pattern for inline editing of any child entity collection, with future applications planned for document text blocks and document-rule junction editing. The component architecture separates presentation concerns through compound components, business logic through custom hooks, and data management through tRPC integration, creating a maintainable foundation for additional edit sheet instances across different entity types.

## Category Type-Ahead Component with Free-Text Input

Implemented a category selection type-ahead component using Shadcn's Popover and Command components to replace the restrictive Select dropdown, enabling users to both choose from existing categories and create new categories inline through free-text input. The implementation shifts category management from a separate CRUD workflow to an integrated inline creation experience embedded directly within the rules editing interface.

The component architecture uses a Popover trigger button displaying the current category name or placeholder text, with a Command component inside the popover providing the searchable interface. CommandInput allows users to type freely, filtering the list of existing categories in real-time with case-insensitive substring matching. As users type, the CommandList dynamically updates to show matching categories under an "Existing Categories" group, and when the input doesn't exactly match any existing category, a "Create New" group appears with a CommandItem offering to create the typed category name as a new entry.

The filtering logic compares the input value against all suggestion strings using lowercase comparison, building a filtered array of matches. The exact match detection determines whether to show the "Create new" option by comparing the lowercased input to all lowercased suggestions, only displaying the creation option when no exact match exists. This prevents duplicate category creation while still allowing users to create variations like different capitalizations if needed. Selection of any item, whether existing or new, updates the value through the onChange callback and closes the popover.

Server-side integration required shifting from category ID-based references to category name-based references in the API layer, though the database schema remains unchanged with rules storing categoryId foreign keys. Input schemas were updated to accept categoryName as a string instead of categoryId as a number, with corresponding changes to CreateRuleInput, UpdateRuleInput, and BatchUpdateRulesInput types. Service functions implement category upsert logic using Prisma's upsert operation with where clause matching the category name, create clause defining the new category with that name, and empty update clause since categories only have name and id fields.

The upsert pattern ensures atomic category creation without race conditions, checking for existence and creating if missing in a single database operation. For batch operations, each new and updated rule triggers its own category upsert before the rule operation, resolving the category name to an ID for storage in the rule's categoryId foreign key. This approach simplifies client-side logic by eliminating the need for ID lookups while maintaining referential integrity at the database level through the foreign key constraint.

Client-side integration into the rules EditSheet required updating the column definition to work with the category object instead of just the category ID. The accessorKey points to the category relation which Prisma populates with the full category object including id and name fields. The viewCell extracts and displays rule.category?.name, while the editCell renders the CategoryTypeAhead component with value from rule.category?.name and onChange updating the entire category object with { name: newCategoryName }. This object-based approach matches EditSheet's expectation that column values represent complete field values rather than just IDs.

Transform logic in RuleListPage's handleSave function extracts categoryName from the category object before sending to the API, mapping over both newRules and updatedRules arrays to add a categoryName property derived from rule.category?.name. This transformation bridges EditSheet's object-based state management with the server's string-based category name API, maintaining clean separation between component layer data structures and API payload formats.

The implementation demonstrates a UX pattern shift from dropdown selection to searchable type-ahead with inline creation, reducing friction in the category assignment workflow. Users can quickly find categories by typing partial names, immediately create new categories without leaving the editing context, and maintain consistent category naming through the suggestion system showing all existing options. The case-insensitive matching helps prevent near-duplicate categories like "Testing" and "testing" by surfacing matches regardless of capitalization, while the database unique constraint on category names provides final enforcement against exact duplicates.
